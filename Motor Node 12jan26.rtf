{\rtf1\ansi\ansicpg1252\cocoartf2867
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fnil\fcharset0 Menlo-Regular;}
{\colortbl;\red255\green255\blue255;\red200\green20\blue201;\red180\green36\blue25;\red0\green0\blue0;
\red193\green101\blue28;\red47\green180\blue29;\red64\green11\blue217;\red158\green76\blue4;}
{\*\expandedcolortbl;;\cssrgb\c83397\c23074\c82666;\cssrgb\c76411\c21697\c12527;\csgray\c0;
\cssrgb\c80555\c47366\c13837;\cssrgb\c20241\c73898\c14950;\cssrgb\c32309\c18666\c88229;\cspthree\c64443\c38839\c13138;}
\margl1440\margr1440\vieww14640\viewh19160\viewkind0
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural\partightenfactor0

\f0\fs12 \cf2 \CocoaLigature0 #include \cf3 <rclcpp/rclcpp.hpp>\cf4 \
\cf2 #include \cf3 <geometry_msgs/msg/twist.hpp>\cf4 \
\cf2 #include \cf3 <gpiod.hpp>\cf4 \
\cf2 #include \cf3 <chrono>\cf4 \
\cf2 #include \cf3 <pigpio.h>\cf4 \
\
\cf5 using\cf4  std::placeholders::_1;\
\cf5 using\cf4  \cf6 namespace\cf4  std::chrono_literals;\
\
\cf6 class\cf4  MotorNode : \cf5 public\cf4  rclcpp::Node\
\{\
\cf5 public\cf4 :\
    MotorNode() : Node(\cf3 "motor_node"\cf4 )\
    \{\
        \cf7 // Initialize GPIO chip (gpiochip0 is standard for Raspberry Pi)\cf4 \
        chip = gpiod::chip(\cf3 "gpiochip0"\cf4 );\
\
        \cf7 // Set BCM GPIO pin numbers used to control motor driver inputs\cf4 \
        in1_pin = \cf3 18\cf4 ; \cf7 // Motor B forward\cf4 \
        in2_pin = \cf3 23\cf4 ; \cf7 // Motor B back\cf4 \
        in3_pin = \cf3 17\cf4 ; \cf7 // Motor A back\cf4 \
        in4_pin = \cf3 27\cf4 ; \cf7 // Motor A forward\cf4 \
\
        \cf7 // Get handles to GPIO lines\cf4 \
        in1 = chip.get_line(in1_pin);\
        in2 = chip.get_line(in2_pin);\
        in3 = chip.get_line(in3_pin);\
        in4 = chip.get_line(in4_pin);\
\
        \cf7 // Request each line as output with initial value LOW (\cf3 0\cf7 )\cf4 \
        \cf7 // The request() function takes:\cf4 \
        \cf7 //   - a consumer name (\cf3 "motor_ctrl"\cf7  helps identify who owns the pin)\cf4 \
        \cf7 //   - a flag that this is a direction OUTPUT\cf4 \
        \cf7 //   - initial value (\cf3 0\cf7  = LOW)\cf4 \
        \cf7 // If this fails, it throws an exception (e.g., if already in use)\cf4 \
        in1.request(\{\cf3 "motor_ctrl"\cf4 , gpiod::line_request::DIRECTION_OUTPUT, \cf3 0\cf4 \});\
        in2.request(\{\cf3 "motor_ctrl"\cf4 , gpiod::line_request::DIRECTION_OUTPUT, \cf3 0\cf4 \});\
        in3.request(\{\cf3 "motor_ctrl"\cf4 , gpiod::line_request::DIRECTION_OUTPUT, \cf3 0\cf4 \});\
        in4.request(\{\cf3 "motor_ctrl"\cf4 , gpiod::line_request::DIRECTION_OUTPUT, \cf3 0\cf4 \});\
\
        right_pwm_pin = \cf3 13\cf4 ;  \cf7 // Motor PMWA Enable/Speed\cf4 \
        left_pwm_pin = \cf3 12\cf4 ; \cf7 // Motor MPWB Enable/Speed\cf4 \
\
\
        \cf7 // Set static pointer for callbacks\cf4 \
        instance = \cf5 this\cf4 ;\
\
        \cf7 // Initialize pigpio\cf4 \
        \cf5 if\cf4  (gpioInitialise() < \cf3 0\cf4 ) \{\
                RCLCPP_ERROR(\cf5 this\cf4 ->get_logger(), \cf3 "Failed to initialize pigpio!"\cf4 );\
                rclcpp::shutdown();\
        \}\
\
     
\fs14         subscription_ = \cf5 this\cf4 ->create_subscription<geometry_msgs::msg::Twist>(\
            \cf3 "/cmd_vel"\cf4 , \cf3 10\cf4 , std::bind(&MotorNode::cmdVelCallback, \cf5 this\cf4 , _1));\
\
        \cf7 // --- Timer to update PWM using encoder feedback ---\cf4 \
        \cf7 //timer_ = this->create_wall_timer(\cf4 \
            \cf7 //50ms, std::bind(&MotorNode::updatePWM, this));\cf4 \
\
        RCLCPP_INFO(\cf5 this\cf4 ->get_logger(), \cf3 "Motor controller node started. Listening to /cmd_vel..."\cf4 );\
    \}\
    ~MotorNode()\
    \{\
        \cf7 // Stop motors on shutdown\cf4 \
        in1.set_value(\cf3 0\cf4 );\
        in2.set_value(\cf3 0\cf4 );\
        in3.set_value(\cf3 0\cf4 );\
        in4.set_value(\cf3 0\cf4 );\
    \}\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural\partightenfactor0
\cf5 private\cf4 :\
    gpiod::chip chip;\
    gpiod::line in1, in2, in3, in4, in5, in6;\
    \cf6 int\cf4  in1_pin, in2_pin, in3_pin, in4_pin, left_pwm_pin, right_pwm_pin;\
\
    rclcpp::Subscription<geometry_msgs::msg::Twist>::SharedPtr subscription_;\
    rclcpp::TimerBase::SharedPtr timer_;\
\
    \cf7 // --- Encoder GPIO ---\cf4 \
    \cf7 //int left_encoder_pin, right_encoder_pin;\cf4 \
    \cf7 //volatile int left_pulse_count = \cf3 0\cf7 ;\cf4 \
    \cf7 //volatile int right_pulse_count = \cf3 0\cf7 ;\cf4 \
\
    \cf6 static\cf4  MotorNode* instance;\
\
        \cf7 // Desired speed set by cmd_vel\cf4 \
        \cf6 int\cf4  desired_left_speed = \cf3 120\cf4 ;\
        \cf6 int\cf4  desired_right_speed = \cf3 120\cf4 ;\
\
        \cf7 // Current PWM values\cf4 \
        \cf6 int\cf4  left_pwm = \cf3 120\cf4 ;\
        \cf6 int\cf4  right_pwm = \cf3 120\cf4 ;\
\
    \cf7 // This callback is called every time a new message is received on /cmd_vel\cf4 \
    \cf7 // Twist messages contain:\cf4 \
    \cf7 //   - linear.x for forward/backward velocity\cf4 \
    \cf7 //   - angular.z for rotation (turning left/right)\cf4 \
    \cf6 void\cf4  setMotorPins(\cf6 bool\cf4  a1, \cf6 bool\cf4  a2, \cf6 bool\cf4  b1, \cf6 bool\cf4  b2)\
    \{\
        in1.set_value(a1);\
        in2.set_value(a2);\
        in3.set_value(b1);\
        in4.set_value(b2);\
    \}\
\
    \cf6 void\cf4  cmdVelCallback(\cf6 const\cf4  geometry_msgs::msg::Twist::SharedPtr msg)\
    \{\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural\partightenfactor0
        \cf7 // ---------- CONSTANTS ----------\cf4 \
        \cf6 constexpr\cf4  \cf6 int\cf4  PWM_BASE = \cf3 135\cf4 ;    \cf7 // slowest reliable motion\cf4 \
        \cf6 constexpr\cf4  \cf6 int\cf4  STEER_RANGE = \cf3 25\cf4 ; \cf7 // max steering effect\cf4 \
\
        \cf6 double\cf4  v = msg->linear.x;   \cf7 // [\cf3 0..1\cf7 ]\cf4 \
        \cf6 double\cf4  w = msg->angular.z;  \cf7 // [-\cf3 1..1\cf7 ]\cf4 \
\
        \cf6 int\cf4  steer = \cf8 static_cast\cf4 <\cf6 int\cf4 >(std::abs(w) * STEER_RANGE);\
\
        \cf6 int\cf4  left_pwm  = PWM_BASE;\
        \cf6 int\cf4  right_pwm = PWM_BASE;\
\
        \cf7 // Set Speed\cf4 \
        \cf8 if\cf4  (w > \cf3 0\cf4 ) \{          \cf7 // turning left\cf4 \
            left_pwm  -= steer * \cf3 3\cf4 ;\
            right_pwm += steer;\
        \}\
        \cf8 else\cf4  \cf8 if\cf4  (w < \cf3 0\cf4 ) \{     \cf7 // turning right\cf4 \
            right_pwm -= steer * \cf3 3\cf4 ;\
            left_pwm  += steer;\
        \}\
\
        \cf7 // Set Direction\cf4 \
        \cf8 if\cf4  (w >.\cf3 18\cf4 )\{\
            gpioPWM(left_pwm_pin, left_pwm);\
            gpioPWM(right_pwm_pin, right_pwm);\
            setMotorPins(\cf3 0\cf4 ,\cf3 1\cf4 ,\cf3 0\cf4 ,\cf3 1\cf4 ); \cf7 // right forward so turn left\cf4 \
        \}\
        \cf8 else\cf4  \cf8 if\cf4  (w < -.\cf3 18\cf4 )\{\
            gpioPWM(left_pwm_pin, left_pwm);\
            gpioPWM(right_pwm_pin, right_pwm);\
            setMotorPins(\cf3 1\cf4 ,\cf3 0\cf4 ,\cf3 1\cf4 ,\cf3 0\cf4 ); \cf7 // left forward\cf4 \
        \}\
        \cf8 else\cf4  \{\
            gpioPWM(left_pwm_pin, left_pwm);\
            gpioPWM(right_pwm_pin, right_pwm);\
            setMotorPins(\cf3 1\cf4 ,\cf3 0\cf4 ,\cf3 0\cf4 ,\cf3 1\cf4 );\
        \}\
\
        RCLCPP_INFO(\
            \cf8 this\cf4 ->get_logger(),\
            \cf3 "v=\cf2 %.2f\cf3  w=\cf2 %.2f\cf3  | PWM L=\cf2 %d\cf3  R=\cf2 %d\cf3 "\cf4 ,\
            v, w, left_pwm, right_pwm\
        );\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural\partightenfactor0
\
\
    \}\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural\partightenfactor0

\fs12 \
    \cf6 void\cf4  updatePWM()\
    \{\
        \cf7 // NOTE**: desired speed is based entirely on pulse count. It should converge to the speed you\cf4 \
        \cf7 // ...you want with this logic.\cf4 \
        \cf7 //\cf4 \
        \cf7 // Copy and reset pulse counts\cf4 \
        \cf6 int\cf4  left_speed = left_pulse_count;\
        \cf6 int\cf4  right_speed = right_pulse_count;\
        left_pulse_count = \cf3 0\cf4 ;\
        right_pulse_count = \cf3 0\cf4 ;\
\
        RCLCPP_INFO(\cf5 this\cf4 ->get_logger(), \cf3 "\cf2 \\n\cf3 left_pulse_count = \cf2 %d\cf3 "\cf4 , left_speed);\
        RCLCPP_INFO(\cf5 this\cf4 ->get_logger(), \cf3 "right_pulse_count = \cf2 %d\cf3 "\cf4 , right_speed);\
\
        \cf7 // --- Simple proportional control ---\cf4 \
        \cf5 if\cf4  (left_speed < desired_left_speed) left_pwm += \cf3 10\cf4 ;\
        \cf5 if\cf4  (left_speed > desired_left_speed) left_pwm -= \cf3 10\cf4 ;\
\
        \cf5 if\cf4  (right_speed < desired_right_speed) right_pwm += \cf3 2\cf4 ;\
        \cf5 if\cf4  (right_speed > desired_right_speed) right_pwm -= \cf3 2\cf4 ;\
\
        \cf7 // Clamp PWM to \cf3 0\cf7 -\cf3 255\cf4 \
        \cf5 if\cf4  (left_pwm < \cf3 0\cf4 ) left_pwm = \cf3 0\cf4 ;\
        \cf5 if\cf4  (left_pwm > \cf3 120\cf4 ) left_pwm = \cf3 120\cf4 ;\
        \cf5 if\cf4  (right_pwm < \cf3 0\cf4 ) right_pwm = \cf3 0\cf4 ;\
        \cf5 if\cf4  (right_pwm > \cf3 120\cf4 ) right_pwm = \cf3 120\cf4 ;\
\
        gpioPWM(left_pwm_pin, left_pwm);\
        gpioPWM(right_pwm_pin, right_pwm);\
    \}\
\
    \cf7 // --- Encoder callbacks ---\cf4 \
    \cf6 static\cf4  \cf6 void\cf4  leftEncoderCallbackStatic(\cf6 int\cf4  gpio, \cf6 int\cf4  level, \cf6 uint32_t\cf4  tick)\
    \{\
        \cf5 if\cf4  (instance) instance->leftEncoderCallback(gpio, level, tick);\
    \}\
\
    \cf6 static\cf4  \cf6 void\cf4  rightEncoderCallbackStatic(\cf6 int\cf4  gpio, \cf6 int\cf4  level, \cf6 uint32_t\cf4  tick)\
    \{\
        \cf5 if\cf4  (instance) instance->rightEncoderCallback(gpio, level, tick);\
    \}\
\
    \cf6 void\cf4  leftEncoderCallback(\cf6 int\cf4  gpio, \cf6 int\cf4  level, \cf6 uint32_t\cf4  tick)\
    \{\
        \cf5 if\cf4  (level == \cf3 1\cf4 ) left_pulse_count++;\
    \}\
\
    \cf6 void\cf4  rightEncoderCallback(\cf6 int\cf4  gpio, \cf6 int\cf4  level, \cf6 uint32_t\cf4  tick)\
    \{\
        \cf5 if\cf4  (level == \cf3 1\cf4 ) right_pulse_count++;\
    \}\
\};\
\
\cf7 // Initialize static instance pointer\cf4 \
MotorNode* MotorNode::instance = \cf3 nullptr\cf4 ;\
\
\cf6 int\cf4  main(\cf6 int\cf4  argc, \cf6 char\cf4  **argv)\
\{\
    rclcpp::init(argc, argv);\
    \cf6 auto\cf4  node = std::make_shared<MotorNode>();\
    rclcpp::spin(node);  \cf7 // spin will stop on Ctrl+C\cf4 \
    rclcpp::shutdown();\
    \cf5 return\cf4  \cf3 0\cf4 ;\
\}\
\
}