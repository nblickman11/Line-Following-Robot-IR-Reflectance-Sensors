#include <rclcpp/rclcpp.hpp>
#include <geometry_msgs/msg/twist.hpp>
#include <gpiod.hpp>
#include <chrono>
#include <pigpio.h>

using std::placeholders::_1;
using namespace std::chrono_literals;

class MotorNode : public rclcpp::Node
{
public:
    MotorNode() : Node("motor_node")
    {
        // Initialize GPIO chip (gpiochip0 is standard for Raspberry Pi)
        chip = gpiod::chip("gpiochip0");

        // Set BCM GPIO pin numbers used to control motor driver inputs
        in1_pin = 18; // Motor B forward
        in2_pin = 23; // Motor B back
        in3_pin = 17; // Motor A back
        in4_pin = 27; // Motor A forward

        // Get handles to GPIO lines
        in1 = chip.get_line(in1_pin);
        in2 = chip.get_line(in2_pin);
        in3 = chip.get_line(in3_pin);
        in4 = chip.get_line(in4_pin);

        // Request each line as output with initial value LOW (0)
        // The request() function takes:
        //   - a consumer name ("motor_ctrl" helps identify who owns the pin)
        //   - a flag that this is a direction OUTPUT
        //   - initial value (0 = LOW)
        // If this fails, it throws an exception (e.g., if already in use)
        in1.request({"motor_ctrl", gpiod::line_request::DIRECTION_OUTPUT, 0});
        in2.request({"motor_ctrl", gpiod::line_request::DIRECTION_OUTPUT, 0});
        in3.request({"motor_ctrl", gpiod::line_request::DIRECTION_OUTPUT, 0});
        in4.request({"motor_ctrl", gpiod::line_request::DIRECTION_OUTPUT, 0});

        right_pwm_pin = 13;  // Motor PMWA Enable/Speed
        left_pwm_pin = 12; // Motor MPWB Enable/Speed


        // Set static pointer for callbacks
        instance = this;

        // Initialize pigpio
        if (gpioInitialise() < 0) {
                RCLCPP_ERROR(this->get_logger(), "Failed to initialize pigpio!");
                rclcpp::shutdown();
        }

             subscription_ = this->create_subscription<geometry_msgs::msg::Twist>(
            "/cmd_vel", 10, std::bind(&MotorNode::cmdVelCallback, this, _1));

        // --- Timer to update PWM using encoder feedback ---
        //timer_ = this->create_wall_timer(
            //50ms, std::bind(&MotorNode::updatePWM, this));

        RCLCPP_INFO(this->get_logger(), "Motor controller node started. Listening to /cmd_vel...");
    }
    ~MotorNode()
    {
        // Stop motors on shutdown
        in1.set_value(0);
        in2.set_value(0);
        in3.set_value(0);
        in4.set_value(0);
    }

private:
    gpiod::chip chip;
    gpiod::line in1, in2, in3, in4, in5, in6;
    int in1_pin, in2_pin, in3_pin, in4_pin, left_pwm_pin, right_pwm_pin;

    rclcpp::Subscription<geometry_msgs::msg::Twist>::SharedPtr subscription_;
    rclcpp::TimerBase::SharedPtr timer_;

    // --- Encoder GPIO ---
    //int left_encoder_pin, right_encoder_pin;
    //volatile int left_pulse_count = 0;
    //volatile int right_pulse_count = 0;

    static MotorNode* instance;

        // Desired speed set by cmd_vel
        int desired_left_speed = 120;
        int desired_right_speed = 120;

        // Current PWM values
        int left_pwm = 120;
        int right_pwm = 120;

    // This callback is called every time a new message is received on /cmd_vel
    // Twist messages contain:
    //   - linear.x for forward/backward velocity
    //   - angular.z for rotation (turning left/right)
    void setMotorPins(bool a1, bool a2, bool b1, bool b2)
    {
        in1.set_value(a1);
        in2.set_value(a2);
        in3.set_value(b1);
        in4.set_value(b2);
    }

    void cmdVelCallback(const geometry_msgs::msg::Twist::SharedPtr msg)
    {

        // ---------- CONSTANTS ----------
        constexpr int PWM_BASE = 135;    // slowest reliable motion
        constexpr int STEER_RANGE = 25; // max steering effect

        double v = msg->linear.x;   // [0..1]
        double w = msg->angular.z;  // [-1..1]

        int steer = static_cast<int>(std::abs(w) * STEER_RANGE);

        int left_pwm  = PWM_BASE;
        int right_pwm = PWM_BASE;

        // Set Speed
        if (w > 0) {          // turning left
            left_pwm  -= steer * 3;
            right_pwm += steer;
        }
        else if (w < 0) {     // turning right
            right_pwm -= steer * 3;
            left_pwm  += steer;
        }

        // Set Direction
        if (w >.18){
            gpioPWM(left_pwm_pin, left_pwm);
            gpioPWM(right_pwm_pin, right_pwm);
            setMotorPins(0,1,0,1); // right forward so turn left
        }
        else if (w < -.18){
            gpioPWM(left_pwm_pin, left_pwm);
            gpioPWM(right_pwm_pin, right_pwm);
            setMotorPins(1,0,1,0); // left forward
        }
        else {
            gpioPWM(left_pwm_pin, left_pwm);
            gpioPWM(right_pwm_pin, right_pwm);
            setMotorPins(1,0,0,1);
        }

        RCLCPP_INFO(
            this->get_logger(),
            "v=%.2f w=%.2f | PWM L=%d R=%d",
            v, w, left_pwm, right_pwm
        );


    }

    void updatePWM()
    {
        // NOTE**: desired speed is based entirely on pulse count. It should converge to the speed you
        // ...you want with this logic.
        //
        // Copy and reset pulse counts
        int left_speed = left_pulse_count;
        int right_speed = right_pulse_count;
        left_pulse_count = 0;
        right_pulse_count = 0;

        RCLCPP_INFO(this->get_logger(), "\nleft_pulse_count = %d", left_speed);
        RCLCPP_INFO(this->get_logger(), "right_pulse_count = %d", right_speed);

        // --- Simple proportional control ---
        if (left_speed < desired_left_speed) left_pwm += 10;
        if (left_speed > desired_left_speed) left_pwm -= 10;

        if (right_speed < desired_right_speed) right_pwm += 2;
        if (right_speed > desired_right_speed) right_pwm -= 2;

        // Clamp PWM to 0-255
        if (left_pwm < 0) left_pwm = 0;
        if (left_pwm > 120) left_pwm = 120;
        if (right_pwm < 0) right_pwm = 0;
        if (right_pwm > 120) right_pwm = 120;

        gpioPWM(left_pwm_pin, left_pwm);
        gpioPWM(right_pwm_pin, right_pwm);
    }

    // --- Encoder callbacks ---
    static void leftEncoderCallbackStatic(int gpio, int level, uint32_t tick)
    {
        if (instance) instance->leftEncoderCallback(gpio, level, tick);
    }

    static void rightEncoderCallbackStatic(int gpio, int level, uint32_t tick)
    {
        if (instance) instance->rightEncoderCallback(gpio, level, tick);
    }

    void leftEncoderCallback(int gpio, int level, uint32_t tick)
    {
        if (level == 1) left_pulse_count++;
    }

    void rightEncoderCallback(int gpio, int level, uint32_t tick)
    {
        if (level == 1) right_pulse_count++;
    }
};

// Initialize static instance pointer
MotorNode* MotorNode::instance = nullptr;

int main(int argc, char **argv)
{
    rclcpp::init(argc, argv);
    auto node = std::make_shared<MotorNode>();
    rclcpp::spin(node);  // spin will stop on Ctrl+C
    rclcpp::shutdown();
    return 0;
}

